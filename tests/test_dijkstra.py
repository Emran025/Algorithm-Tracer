import pytest
from app.algorithms.dijkstra import dijkstra_generator
from app.utils.types import Event, Graph

def test_dijkstra_basic_graph():
    """Test Dijkstra's algorithm on a basic connected graph."""
    graph = {
        'A': [('B', 1), ('C', 4)],
        'B': [('A', 1), ('C', 2), ('D', 5)],
        'C': [('A', 4), ('B', 2), ('D', 1)],
        'D': [('B', 5), ('C', 1)]
    }
    start_node = 'A'
    expected_distances = {'A': 0, 'B': 1, 'C': 3, 'D': 4}

    events = list(dijkstra_generator(graph, start_node))

    assert len(events) > 0
    final_event = events[-1]
    assert final_event.type == "done"
    assert "final_distances" in final_event.data

    actual_distances = {k: v for k, v in final_event.data["final_distances"].items() if v != 'inf'}
    assert actual_distances == expected_distances

def test_dijkstra_unreachable_nodes():
    """Test Dijkstra's with unreachable nodes."""
    graph = {
        'A': [('B', 1)],
        'B': [('A', 1)],
        'C': [('D', 1)],
        'D': [('C', 1)]
    }
    start_node = 'A'
    expected_distances = {'A': 0, 'B': 1, 'C': 'inf', 'D': 'inf'}

    events = list(dijkstra_generator(graph, start_node))

    final_event = events[-1]
    assert final_event.type == "done"
    assert final_event.data["final_distances"] == expected_distances

def test_dijkstra_negative_weights():
    """Test Dijkstra's algorithm with negative weights (should abort)."""
    graph = {
        'A': [('B', -1)],
        'B': [('C', 2)],
        'C': []
    }
    start_node = 'A'

    events = list(dijkstra_generator(graph, start_node))

    assert any(e.type == "error" for e in events)
    final_event = events[-1]
    assert final_event.type == "done"
    assert "aborted due to negative weights" in final_event.details

def test_dijkstra_empty_graph():
    """Test Dijkstra's algorithm on an empty graph."""
    graph = {}
    # For an empty graph, start_node 'A' is not present, so the generator should handle this gracefully.
    # The current implementation of dijkstra_generator will initialize distances as {} if graph is {}.
    # It will then attempt distances[start_node] = 0, which would raise a KeyError if start_node is not in graph.
    # Let's adjust the test to reflect the expected behavior of an empty graph with a non-existent start_node.
    # If the graph is empty, the generator should yield an empty final_distances.
    start_node = 'A'
    events = list(dijkstra_generator(graph, start_node))

    assert len(events) > 0
    final_event = events[-1]
    assert final_event.type == "done"
    assert final_event.details == "Dijkstra's algorithm aborted due to invalid start node or empty graph."
    assert final_event.data == {}

def test_dijkstra_single_node_graph():
    """Test Dijkstra's algorithm on a graph with a single node."""
    graph = {"A": []}
    start_node = 'A'
    expected_distances = {'A': 0}

    events = list(dijkstra_generator(graph, start_node))

    final_event = events[-1]
    assert final_event.type == "done"
    assert final_event.data["final_distances"] == expected_distances

def test_dijkstra_all_events_conform_schema():
    """Test that all events generated by Dijkstra's conform to the schema."""
    graph = {
        'A': [('B', 1)],
        'B': [('C', 2)],
        'C': []
    }
    start_node = 'A'
    events = list(dijkstra_generator(graph, start_node))

    for event in events:
        assert isinstance(event, Event)
        assert isinstance(event.step, int)
        assert isinstance(event.type, str)
        assert isinstance(event.details, str)
        assert isinstance(event.data, dict)

